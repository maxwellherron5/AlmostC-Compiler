package semanticanalyzer;

import symboltable.SymbolTable.DataType;
import symboltable.SymbolTable;
import syntaxtree.*;

import java.lang.reflect.Array;
import java.util.ArrayList;

/**
 *
 * @author Maxwell Herron
 */
public class SemanticAnalyzer {

    /** This flag will be set to false if a semantic error is detected. */
    private boolean canWriteAssembly = true;

    /** The root of the syntax tree that is being analyzed. */
    private ProgramNode progNode;

    /** The symbol table generated by the syntax tree. */
    private SymbolTable table;

    /**
     * Base constructor.
     * @param progNode input syntax tree.
     * @param table symbol table generated by syntax tree.
     */
    public SemanticAnalyzer(ProgramNode progNode, SymbolTable table) {
        this.progNode = progNode;
        this.table = table;
    }

    /**
     * Checks ExpressionNodes to ensure that all variables within have been declared.
     */
    public void checkIdentifiersDeclaration() {

        ArrayList<String> variables = getVariables(progNode.getMain());
        ArrayList<String> allVariables = new ArrayList();
        String[] stringArray = progNode.indentedToString(0).split(" ");
        for (int i = 0; i < stringArray.length; i++) {
            if (stringArray[i].equals("Name:")) {
                String var = stringArray[i+1];
                var = var.split("\n")[0];
                if (!allVariables.contains(var)) {
                    allVariables.add(var);
                }
            }
        }
        for (String s : allVariables) {
            if (!variables.contains(s)) {
                System.out.println("Undeclared variable: " + s + ".\tPlease declare this variable.");
                canWriteAssembly = false;
            }
        }
    }

    /**
     * Assigns data types to all ExpressionNodes.
     */
    public void assignDatatypes() {

        ArrayList<StatementNode> stateList = progNode.getMain().getStatements();

        for (StatementNode statement : stateList) {
            if (statement instanceof AssignmentStatementNode) {
                DataType lType = ((AssignmentStatementNode) statement).getLvalue().getType();

            }
            else if (statement instanceof WriteStatementNode) {
                setExpressionType(((WriteStatementNode) statement).getOutput());
            }
            else if (statement instanceof ReadStatementNode) {

            }
            else if (statement instanceof CompoundStatementNode) {

            }
            else if (statement instanceof IfStatementNode) {

            }
            else if (statement instanceof WhileStatementNode) {

            }
            else if (statement instanceof ReturnStatementNode) {

            }
        }
    }

    /**
     * Checks type matching across assignment
     */
    public void checkAssignmentTypes() {

        ArrayList<StatementNode> stateList = progNode.getMain().getStatements();

        for (StatementNode statement : stateList) {
            if (statement instanceof AssignmentStatementNode) {
                VariableNode lNode = ((AssignmentStatementNode) statement).getLvalue();
                //SymbolTable.DataType;
            }
        }
    }

    /**
     * Sets the data type of the input ExpressionNode
     * @param expNode ExpressionNode that is having its type set
     */
    private void setExpressionType(ExpressionNode expNode) {

        if (expNode instanceof FunctionCallNode) {

        }
        else if(expNode instanceof OperationNode) {

        }
        else if (expNode instanceof ValueNode) {

        }
        else if (expNode instanceof VariableNode) {

        }
    }

    /**
     *
     * @param body
     * @return
     */
    public ArrayList<String> getVariables(CompoundStatementNode body) {

        ArrayList<String> variables = new ArrayList();
        ArrayList<VariableNode> variableNodes = body.getVariables().getVars();
        for (VariableNode node : variableNodes) {
            variables.add(node.getName());
        }
        return variables;
    }

    // Getters
    public boolean getCanWriteAssembly() { return canWriteAssembly; }
}
