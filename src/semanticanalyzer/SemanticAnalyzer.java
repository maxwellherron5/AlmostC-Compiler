package semanticanalyzer;

import symboltable.*;
import syntaxtree.*;

import java.lang.reflect.Array;
import java.util.ArrayList;

/**
 *
 * @author Maxwell Herron
 */
public class SemanticAnalyzer {

    /** This flag will be set to false if a semantic error is detected. */
    private boolean canWriteAssembly = true;

    /** The root of the syntax tree that is being analyzed. */
    private ProgramNode progNode;

    /** The symbol table generated by the syntax tree. */
    private SymbolTable table;

    /**
     * Base constructor.
     * @param progNode input syntax tree.
     * @param table symbol table generated by syntax tree.
     */
    public SemanticAnalyzer(ProgramNode progNode, SymbolTable table) {
        this.progNode = progNode;
        this.table = table;
    }

    /**
     * Checks ExpressionNodes to ensure that all variables within have been declared.
     */
    public void checkIdentifiersDeclaration() {

        ArrayList<String> variables = getVariables(progNode.getMain());


    }

    /**
     * Assigns data types to all ExpressionNodes.
     */
    public void assignDatatypes() {

        ArrayList<StatementNode> stateList = progNode.getMain().getStatements();

        for (StatementNode statement : stateList) {
            if (statement instanceof AssignmentStatementNode) {

            }
            else if (statement instanceof WriteStatementNode) {
                setExpressionType(((WriteStatementNode) statement).getOutput());
            }
        }
    }

    /**
     * Checks type matching across assignment
     */
    public void checkAssignmentTypes() {

        ArrayList<StatementNode> stateList = progNode.getMain().getStatements();

        for (StatementNode statement : stateList) {
            if (statement instanceof AssignmentStatementNode) {
                VariableNode lNode = ((AssignmentStatementNode) statement).getLvalue();
                SymbolTable.DataType
            }
        }
    }

    /**
     * Sets the data type of the input ExpressionNode
     * @param expNode ExpressionNode that is having its type set
     */
    public void setExpressionType(ExpressionNode expNode) {


    }

    /**
     *
     * @param body
     * @return
     */
    public ArrayList<String> getVariables(CompoundStatementNode body) {

        ArrayList<String> variables = new ArrayList();
        ArrayList<VariableNode> variableNodes = body.getVariables().getVars();
        for (VariableNode node : variableNodes) {
            variables.add(node.getName());
        }
        return variables;
    }


    // Getters
    public boolean getCanWriteAssembly() { return canWriteAssembly; }
}
